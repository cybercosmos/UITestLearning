from __future__ import print_function

import random
import string
import sys

from uiautomator import Device

import Utility
from Config import Config
from Data import Data

d = Device(Config.device_name)

pack_name = Config.pack_name
app_name = Config.app_name


def click_button_intelligently_from(buttons, data_activity, curr_state):
    """
    Choosing the right button to click by determining if state changes, and changing the respective scores.
    :param buttons: all possible button choices.
    :param data_activity: activity data structure
    :param curr_state: current state
    :return:
    """
    btn_to_click = make_button_decision(buttons, data_activity)
    if btn_to_click is None:
        print('No buttons to click')
        return None
    btn_to_click.click.wait()
    if Utility.get_state(d) == curr_state:
        print('nothing changed')
        data_activity.get_clickable_by_name(Utility.btn_to_key(btn_to_click)).score -= 1
        return 'Nothing changed'
    elif Utility.get_state(d) != curr_state:
        print('changed state')
        return 'Changed'
    # add mutation


def make_button_decision(buttons, data_activity):
    """
    Supervised learning, to make the decision of choosing the right buttons to click.
    :param buttons: all possible button choices.
    :param data_activity: current activity data storage
    :return: returns the button to be clicked.
    """
    max_val = -9999
    max_btns = []
    if len(buttons) == 0:
        return None
    elif len(buttons) == 1:
        return buttons[0]
    else:
        for btn in buttons:
            score = data_activity.get_clickable_by_name(Utility.btn_to_key(btn)).score
            if score > max_val:
                max_btns = [btn]
                max_val = score
            elif score == max_val:
                max_btns.append(btn)
        return random.choice(max_btns)


def get_text():
    """
    Getting random 15 characters and join them.
    :return: random string
    """
    return ''.join(random.choices(string.ascii_lowercase + string.ascii_uppercase + string.digits, k=15))


def main():
    d.screen.on()
    d.press('home')
    d(resourceId='com.google.android.apps.nexuslauncher:id/all_apps_handle').click()
    d(text=app_name).click.wait()

    learning_data = Utility.load_data(app_name)
    if learning_data is None:
        print('Initializing...')
        learning_data = Data(appname=app_name, packname=pack_name)
        learning_data.add_new_activity(d)

    click_els = d(clickable='true', packageName=pack_name)
    edit_box = []
    buttons = []
    for el in click_els:
        if el.info['className'] == Config.edit_widget:
            edit_box.append(el)
        elif el.info['className'] in (
                Config.button_widget, Config.image_button_widget, Config.image_view_button_widget):
            buttons.append(el)

    for edit in edit_box:
        edit.set_text(get_text())

    while True:
        try:
            curr_state = Utility.get_state(d)
            btn_clicked = click_button_intelligently_from(buttons, learning_data.get_activity_by_state(curr_state),
                                                          curr_state)
            if btn_clicked is None:
                break
        except KeyboardInterrupt:
            print('boohoohoo')
            Utility.store_data(learning_data, app_name)
            sys.exit(0)


main()


# """ XML Testing """
# x = d.dump()
# tree = ET.fromstring(x)
# parent_map = dict((c, p) for p in tree.iter() for c in p)
# # print(parent_map)
# click_els = d(clickable='true', packageName=pack_name)
#
# # print(click_els[0].info['className'])
# # print(click_els[0].info['bounds'])
# # parent = get_parent(click_els[0], parent_map)
# # children = parent.findall('node')
# # for child in children:
# #     print(child.attrib['bounds'])
# """ End of XML Testing """





"""
buttons to P1 or P2
Determine which activity page is more useful.
determine what kind of bonus scores to give regarding the next page 

Store more details in the first runs
to collect parent and child nodes as well
discriminiation between what is filled in and what is generated by system
contextual meanings (siblings/parents/children) e.g. 1-away
relationship distance = 1
list of data for what will be collectedz

literature review of model for sentimental analysis-like analysis 
twitter-like NN model
"""
